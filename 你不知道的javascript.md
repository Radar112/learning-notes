# 你不知道的Javescirpt读书笔记  

## （上卷）  

### 第一章 作用域是什么

1.1 编译三步骤：分词/词法分析、解析/语法分析、代码生成。  
1.2 理解作用域，作用域学习三兄弟：**引擎、编译器、作用域。**  
1.3 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。  
1.4 LHS和RHS查询：当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。讲得更准确一点，RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。  
  
>ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。  
  
1.5 作用域定义
> 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。 ＝ 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。 

**重点（预编译过程）  
  1 创建AO对象 （Activation Object）(执行期上下文)  
  2 找形参和变量声明，将变量声明和形参名作为AO属性名，值为undefined  
  3 将实参值和形参值相统一  
  4 在函数体里面找函数声明，值赋予函数体**

***

### 第二章 词法作用域

1.1 定义：**简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。**  

1.2 **区分函数声明和表达式：看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。**  

### 第四章 变量和函数声明的提升  

1 函数优先：函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。  

### 第五章 作用域闭包

1 定义：**当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。**
2 实例:  

    ```js  
    function foo() {
      var a = 2;
      function bar() {
        console.log( a );
      }
      return bar;
    }
    var baz = foo();
    baz(); // 2 —— 朋友，这就是闭包的效果。  
    ```  

3 模块模式需要具备两个必要条件：  
   (1). 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。  
   (2). 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。  

### 第五章 this和对象原型  

1 对this的误解：**把 this 理解成指向函数自身**，**this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下它却是错误的。**  
2 具名函数，在它内部可以使用 foo 来引用自身。  
3 this到底是什么？  
   > this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。 this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。 this 就是记录的其中一个属性，会在函数执行的过程中用到.  

4 **this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。**
5 调用栈：就是为了到达当前执行位置所调用的所有函数.我们关心的调用位置就在当前正在执行的函数的前一个调用中。
6 绑定规则：
  1). **默认绑定**最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。  
  2). **隐式绑定**另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些在分隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上.  

    ```js
    function foo() {
      console.log( this.a );
    }
    var obj = {
      a: 2,
      foo: foo
    };
    obj.foo(); // 2
    ```  
   3). **显示绑定**JavaScript 提供的绝大多数函数以及你自己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。这两个方法是如何工作的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到this ，接着在调用函数时指定这个 this 。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定。  
   4). **new绑定**包括内置对象函数（比如 Number(..) ，详情请查看第 3 章）在内的所有函数都可以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。
   使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。  
     4.1). 创建（或者说构造）一个全新的对象。  
     4.2). 这个新对象会被执行 [[ 原型 ]] 连接。  
     4.3). 这个新对象会绑定到函数调用的 this 。  
     4.4). 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。  
   5). 箭头函数绑定  

7 判断this
    7.1. 函数是否在 new 中调用（ new 绑定）？如果是的话 this 绑定的是新创建的对象。  
       var bar = new foo()  
    7.2. 函数是否通过 call 、 apply （显式绑定）或者硬绑定调用？如果是的话， this 绑定的是指定的对象。  
       var bar = foo.call(obj2)  
    7.3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话， this 绑定的是那个上下文对象。  
       var bar = obj1.foo()  
    7.4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined ，否则绑定到全局对象。  
       var bar = foo()  

8 小结  
    如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。
    1. 由 new 调用？绑定到新创建的对象。
    2. 由 call 或者 apply （或者 bind ）调用？绑定到指定的对象。
    3. 由上下文对象调用？绑定到那个上下文对象。
    4. 默认：在严格模式下绑定到 undefined ，否则绑定到全局对象。  
    一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null) ，以保护全局对象。ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this ，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这其实和 ES6 之前代码中的 self = this 机制一样.  

### 第六章 对象

1 .a 语法通常被称为“属性访问”， ["a"] 语法通常被称为“键访问”。  
2 注意，简单基本类型（ string 、 boolean 、 number 、 null 和 undefined ）本身并不是对象。null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行typeof null 时会返回字符串 "object".实际上,null本身是基本类型  
3 内置对象：JavaScript 中还有一些对象子类型(String,Number,Boolean,Object,Function,Array,Date,RegExp,Error)，通常被称为内置对象。有些内置对象的名字看起来和简单基础类型一样，不过实际上它们的关系更复杂.
4 内容：对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，我们称之为属性。需要强调的一点是，当我们说“内容”时，似乎在暗示这些值实际上被存储在对象内部，但是这只是它的表现形式。在引擎内部，这些值的存储方式是多种多样的，一般并不会存在对象容器内部。存储在对象容器内部的是这些属性的名称，它们就像指针（从技术角来说就是引用）一样，指向这些值真正的存储位置。
5 可计算属性名：ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名

```js
  var prefix = "foo";
  var myObject = {
    [prefix + "bar"]:"hello",
    [prefix + "baz"]: "world"
  };
  myObject["foobar"]; // hello
  myObject["foobaz"]; // world
```

6 属性描述符

   ```js
   var myObject = {
      a:2
   };
   Object.getOwnPropertyDescriptor( myObject, "a" );
   // {
   // value: 2,
   // writable: true,             writable 决定是否可以修改属性的值。
   // enumerable: true,           enumerable这个描述符控制的是属性是否会出现在对象的属性枚举中，比如说for..in 循环。如果把 enumerable 设置成 false ，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。
   // configurable: true          configurable只要属性是可配置的，就可以使用 defineProperty(..) 方法来修改属性描述符
   // }
   ```

   如你所见，这个普通的对象属性对应的属性描述符（也被称为“数据描述符”，因为它只保存一个数据值）可不仅仅只是一个 2。它还包含另外三个特性： writable （可写）、enumerable （可枚举）和 configurable （可配置）。在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..)来添加一个新属性或者修改一个已有属性（如果它是 configurable ）并对特性进行设置。  

7 不可变性  
   7.1 **对象常量**，结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性（不可修改、重定义或者删除）  
   7.2 **禁止扩展**，如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 Object.preventExtensions(..)  
   7.3 **密封**，Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false.所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可修改属性的值）。  
   7.4 **冻结**，Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用Object.seal(..) 并把所有“数据访问”属性标记为writable:false ，这样就无法修改它们的值。这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改（不   过就像我们之前说过的，这个对象引用的其他对象是不受影响的）。  

8 "[[Get]]"和"[[Put]]"  
   8.1 Get:var myObject = {a: 2};myObject.a; // 2  myObject.a 是一次属性访问，但是这条语句并不仅仅是在 myObjet 中查找名字为 a 的属性，虽然看起来好像是这样。在语言规范中,myObject.a 在 myObject 上实际上是实现了Get操作(有点像函数调用:Get())。对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值然而，如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要的行为。我们会在第 5 章中介绍这个行为（其实就是遍历可能存在的 [[Prototype]] 链，也就是原型链）.  
   8.2 [[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性（这是最重要的因素）。如果已经存在这个属性， [[Put]] 算法大致会检查下面这些内容。
   1). 属性是否是访问描述符（参见 3.3.9 节）？如果是并且存在 setter 就调用 setter。
   2). 属性的数据描述符中 writable 是否是 false ？如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。
   3). 如果都不是，将该值设置为属性的值。  

9 存在性
   我们可以在不访问属性值的情况下判断对象中是否存在这个属性：

   ```js
   var myObject = {
     a:2
   };
   ("a" in myObject); // true
   ("b" in myObject); // false
   myObject.hasOwnProperty( "a" ); // true
   myObject.hasOwnProperty( "b" ); // false
   ```

   in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中（参见第 5 章）。相比之下，hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。ropertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 enumerable:true 。Object.keys(..) 会返回一个数组，包含所有可枚举属性， Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举。in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而， Object.keys(..)和 Object.getOwnPropertyNames(..)都只会查找对象直接包含的属性。  

10 遍历
  10.1 forEach(..) 会遍历数组中的所有值并忽略回调函数的返回值。 every(..) 会一直运行直到回调函数返回 false （或者“假”值）， some(..) 会一直      运行直到回调函数返回 true （或者“真”值）。  
       every(..) 和 some(..) 中特殊的返回值和普通 for 循环中的 break 语句类似，它们会提前终止遍历。  
       使用 for..in 遍历对象是无法直接获取属性值的，因为它实际上遍历的是对象中的所有可枚举属性，你需要手动获取属性值。  

### 第七章 混合对象“类”  

1 类理论：类/继承描述了一种代码的组织结构形式——一种在软件中对真实世界中问题领域的建模方法。**面向对象编程强调的是数据和操作数据的行为本质上是互相关联的（当然，不同的数据有不同的行为），因此好的设计就是把数据以及和它相关的行为打包（或者说封装）起来。这在正式的计算机科学中有时被称为数据结构。**  
2 类有实例化、继承性和多态性。  多态，这个概念是说父类的通用行为可以被子类用更特殊的行为重写。实际上，相对多态性允许我们从重写行为中引用基础行    为。  

***

### 第八章 原型

1 **属性屏蔽**：如果属性名(foo)既出现在当前对象(myObject)中也出现在当前对象的 [[Prototype]] 链上层，那么就会发生屏蔽。 myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为myObject.foo 总是会选择原型链中最底层的foo属性。  
2 **差异继承**：基本原则是在描述对象行为时，使用其不同于普遍描述的特质。举例来说，描述汽车时你会说汽车是有四个轮子的一种交通工具，但是你不会重复描述交通工具具备的通用特性（比如引擎）。  
3 **内省（反射）**：在传统的面向类环境中，检查一个实例（JavaScript中的对象）的继承祖先（JavaScript 中的委托关联）通常被称为内省（或者反射）  
4 instanceof,instanceof 操作符的左操作数是一个普通的对象，右操作数是一个函数。 instanceof 回答的问题是：在 a 的整条 [[Prototype]] 链中是否有指向 Foo.prototype 的对象？可惜，这个方法只能处理对象（ a ）和函数（带 .prototype 引用的 Foo ）之间的关系。如果你想判断两个对象（比如 a 和 b ）之间是否通过 [[Prototype]] 链关联，只用 instanceof无法实现。  

***

***

***

***

## （中卷）

### 第一部分 类型和语法

#### 第一章 类型

> 本书中，我们这样来定义“类型”（与规范类似）：对语言引擎和开发人员来说，类型是值的内部特征，它定义了值的行为，以使其区别于其他值。  
> polyfill:即衬垫代码或者补充代码，用来补充当前运行环境中缺失的功能

1.1 js七种内置类型：**null(空值）、undefined(未定义)、boolean(布尔值)、number(数字)、string(字符串)、object(对象)和symbol(符号)**。除对象外其他为基本类型。  
1.2 函数(function)实际上是 object 的一个“子类型”。具体来说，函数是“可调用对象”，它有一个内部属性 [[Call]] ，该属性使其可以被调用。  
1.3 **JavaScript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。在对变量执行 typeof 操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类型，因为 JavaScript 中的变量没有类型。**  
1.4 很多开发人员将 undefined 和 undeclared 混为一谈，但在 JavaScript 中它们是两码事。undefined 是值的一种。undeclared 则表示变量还没有被声明过。
遗憾的是，JavaScript 却将它们混为一谈，在我们试图访问 "undeclared" 变量时这样报错：ReferenceError: a is not defined，**并且 typeof 对 undefined 和 undeclared 变量都返回"undefined" 。**然而，通过 typeof 的安全防范机制（阻止报错）来检查 undeclared 变量，有时是个不错的办法。

***

#### 第二章 值

2.1 数组：在 JavaScript 中，数组可以容纳任何类型的值，可以是字符串、数字、对象（ object ），甚至是其他数组（多维数组就是通过这种方式来实现的），对数组声明后即可向其中加入值，不需要预先设定大小
> 使用 delete 运算符可以将单元从数组中删除，但是请注意，单元删除后，数组的 length 属性并不会发生变化  

##### 常用数组操作方法  

###### 不改变原数组的方法

1. join()方法，将数组中所有的元素用参数中指定的分隔符分隔，并放入一个字符串中。不改变原数组  
2. concat()方法，连接两个或多个数组，不改变原数组。  
3. slice(start, end)方法，从调用数组中返回从start开始，end结束的（含头不含尾）一个新数组，不改变原数组。  

###### 能改变原数组的方法  

1. pop()方法，删除数组中的最后一个元素，返回被删除的元素值。  
2. push()方法，向数组的末尾添加一个或多个元素，返回新的长度。  
3. shift()方法，删除数组中的第一个元素，返回被删除的元素值。  
4. unshift()方法，向数组中的首部添加一个或多个元素，返回新的长度。  
5. splice(start，end，newvalue)方法，删除数组中从start到end的元素，并用新值来替换被删除的位置。返回被删除元素组成的数组。  
6. reverse()方法，颠倒数组元素的顺序。  
7. sort()方法，对数组中的元素按Unicode code编码位置进行排序，默认升序。  

```js
const arr = [1, 2, 3];
const arr1 = [4, 5, 6];
const arr2 = [1, 9, 0, 3, 5, 7, 12, 98];
let str = 'abcd112';

// let a = arr.join('_');          不改变原数组，返回字符串
// let a = arr.concat(arr1);       不改变原数组，返回被连接的数组的副本
// let a = arr.slice(1, 2);        不改变原数组，返回被选择的元素的数组

// let a = arr.pop();              改变原数组，返回被删除的元素值
// let a = arr.push('a');          改变原数组，返回数组新的长度
// let a = arr.shift();            改变原数组，返回删除的元素值
// let a = arr.unshift(0, "a");    改变原数组，返回新的数组长度
// let a = arr.splice(0, 3, 'a');  改变原数组，返回被删除的元素的数组
// let a = arr.reverse();          改变原数组，直接对原数组进行颠倒操作   
// let a = arr2.sort();            改变原数组，没有参数时按照Unicode code编码位置排序，默认升序

// let a = str.substr(2, 6);
// let b = str.substring(2, 6);
console.log(a);
console.log(arr);
```

###### 其他方法  

1. indexOf和lastIndesOf,都接受两个参数：查找的值、查找的起始位置。不存在返回-1，存在返回位置（数组下标）。  
2. every（），对素组每一项都运行给定的函数，每一项都返回true，则返回true。  
3. some（），对素组每一项都运行给定的函数，任意一项都返回true，则返回true。  
4. filter（），对素组每一项都运行给定的函数，返回的是每次调用函数结果为true的值组成的一个新数组。  
5. map（），对素组每一项都运行给定的函数，返回的是每次调用函数结果组成的一个新数组。  
6. forEach(),数组遍历。  
7. find（），传入一个回调函数，找到数组中符合当前搜索规则的的一个元素，返回它，并终止搜索。  
8. findIndex（），传入一个回调函数，找到数组中符合当前搜索规则的的一个元素，返回它的下标，并终止搜索。  
9. fill（），用新元素替换掉数组中的元素，可以指定提换下标范围。`arr.fill(value, start, end)`  
10. copyWinthin(),选择数组的某个下标，从该位置开始复制数组元素，默认从0开始，也可以指定复制范围。  
11. form（），将类数组和可遍历的对象转换为数组。  
12. of（），用于将一组值转换为数组。  
13. entries()、values()、keys()方法，分别返回键值对、值和键。  
14. includes(findValue, start),判断数组中是否存在findValue元素,start为起始位置。  

2.2 字符串：字符串和数组的确很相似，它们都是类数组，都有 length 属性以及 indexOf(..) （从 ES5开始数组支持此方法）和 concat(..) 方法  
   > JavaScript 中字符串是不可变的，而数组是可变的。字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。  
**字符串反转（JavaScript 面试常见问题）。数组有一个字符串没有的可变更成员函数 reverse()**一个变通（破解）的办法是先将字符串转换为数组，待处理完后再将结果转换回字符串：

```js
var c = a
// 将a的值转换为字符数组
.split( "" )
// 将数组中的字符进行倒转
.reverse()
// 将数组中的字符拼接回字符串
.join( "" );
c; // "oof"
```

这种方法的确简单粗暴，但对简单的字符串却完全适用。  

2.3 数字：JavaScript 只有一种数值类型： number （数字），包括“整数”和带小数的十进制数。数字前面的 0 可以省略；特别大和特别小的数字默认用指数格式显示，    与 toExponential() 函数的输出结果相同。42.tofixed(3) 是无效语法，因为 . 被视为常量 42. 的一部分（如前所述），所以没有 . 属性访问运算符来调         tofixed 方法。42..tofixed(3) 则没有问题，因为第一个 . 被视为 number 的一部分，第二个 . 是属性访问运算符。数字常量还可以用其他格式来表示，如二进     制、八进制和十六进制。建议尽量使用小写的0x、0b和0o。  
> 二进制浮点数最大的问题（不仅 JavaScript，所有遵循 IEEE 754 规范的语言都是如此），是会出现如下情况：0.1 + 0.2 === 0.3; // false  从数学角度来说，上面的条件判断应该为 true ，可结果为什么是 false 呢？简单来说，二进制浮点数中的 0.1 和 0.2 并不是十分精确，它们相加的结果并非刚好等于0.3 ，而是一个比较接近的数字 0.30000000000000004 ，所以条件判断结果为 false 。  

2.3.1 那么应该怎样来判断 0.1 + 0.2 和 0.3 是否相等呢？  
  最常见的方法是设置一个误差范围值，通常称为“机器精度”（machine epsilon），对JavaScript 的数字来说，这个值通常是 2^-52 (2.220446049250313e-16)。  
从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用，也可以为 ES6 之前的版本写 polyfill：  

```js
if (!Number.EPSILON) {
  Number.EPSILON = Math.pow(2,-52);
}
//可以使用 Number.EPSILON 来比较两个数字是否相等（在指定的误差范围内）：
function numbersCloseEnoughToEqual(n1,n2) {
  return Math.abs( n1 - n2 ) < Number.EPSILON;
}
var a = 0.1 + 0.2;
var b = 0.3;
numbersCloseEnoughToEqual( a, b ); // true
numbersCloseEnoughToEqual( 0.0000001, 0.0000002 ); // false
```

2.3.2 能够呈现的最大浮点数大约是 1.798e+308 （这是一个相当大的数字），它定义在 Number.MAX_VALUE 中。最小浮点数定义在 Number.MIN_VALUE 中，大约是 5e-324 ，它不是负数，但无限接近于 0 ！能够被“安全”呈现的最大整数是 2^53 - 1 ，即 9007199254740991 ，在 ES6 中被定义为Number.MAX_SAFE_INTEGER 。最小整数是 -9007199254740991 ，在 ES6 中被定义为 Number.MIN_SAFE_INTEGER 。要检测一个值是否是整数，可以使用 ES6 中的 Number.isInteger(..) 方法;要检测一个值是否是安全的整数，可以使用 ES6 中的 Number.isSafeInteger(..) 方法;undefined 类型只有一个值，即 undefined 。 null 类型也只有一个值，即 null 。它们的名称既是类型也是值。  
2.3.3 NaN:如果数学运算的操作数不是数字类型（或者无法解析为常规的十进制或十六进制数字）就无法返回一个有效的数字，这种情况下返回值为 NaN 。NaN 意指“不是一个数字”（not a number），这个名字容易引起误会，后面将会提到。将它理解为“无效数值”“失败数值”或者“坏数值”可能更准确些。
2.3.4 特殊等式：如前所述， NaN 和 -0 在相等比较时的表现有些特别。由于 NaN 和自身不相等，所以必须使用 ES6 中的 Number.isNaN(..) （或者 polyfill）。而 -0 等于 0 （对于 === 也是如此，参见第4 章），因此我们必须使用 isNegZero(..) 这样的工具函数。ES6 中新加入了一个工具方法 Object.is(..) 来判断两个值是否绝对相等，可以用来处理上述所有的特殊情况。  
2.3.5 值和引用：**JavaScript 对值和引用的赋值 / 传递在语法上没有区别，完全根据值的类型来决定。简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来赋值 / 传递，包括null 、 undefined 、字符串、数字、布尔和 ES6 中的 symbol 。复合值（compound value）——对象（包括数组和封装对象，参见第 3 章）和函数，则总是通过引用复制的方式来赋值 / 传递。**